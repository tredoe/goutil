// Copyright 2012 Jonas mg
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
Command go.mkdef reads a file containing cgo prototypes and generates the
definitions (constants, types) using cgo tool.
The prototypes are marked by lines beginning with "//cgo" and read according
the next rules:

	* A simple constant, like
	  //cgo const FOO
	* If Go constant name needs to be different from its C name,
	  the C name could be specified at the end, after "=" sign, like
	  //cgo const FOO = FOOA

	* Multiple constants, like
	  //cgo const (FOO, BAR)
	* Multiple lines for multiple constants, like
	  //cgo const (FOO, BAR,
	  // QWE)
	* Comment before of the constant definition, like
	  //cgo// This is a comment

	* Types, like
	  //cgo type struct_foo
	  //cgo type union_foo
	  //cgo type enum_foo

	* The exportation can be provided at start of //cgo declaration, like
	  //cgo [export=true] const (FOO, BAR)

	  Otherwise, it will get the value of flag -export

When the ouput is written to file (flag -w), the file name generated is got
using the prefix "z-sys_", and adding both system and architecture.
*/
package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"go/scanner"
	"go/token"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

const (
	PREFIX         = "//cgo"
	PREFIX_COMMENT = "//cgo//"
)

var HEADER = "// MACHINE GENERATED BY go.mkdef (github.com/tredoe/goutil/go.mkdef); DO NOT EDIT\n"

// Flags
var (
	Debug  = flag.Bool("d", false, "debug; print the temporary file to be used by cgo")
	Write  = flag.Bool("w", false, "write output to file")
	Export = flag.Bool("export", true, "the definitions to generate are exported, by default")
	WinGCC = flag.String("win-gcc", `C:\MinGW`, "directory of MinGW (GCC) compiler suite; for Windows")
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: go.mkdef [-w] file...
Generate Go definitions from cgo prototypes which are passed to cgo tool.

`)
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	flag.Usage = usage
	flag.Parse()

	if len(os.Args) == 1 {
		usage()
	}

	log.SetFlags(0)
	log.SetPrefix("FAIL! ")

	exitCode := 0
	proto := NewPrototype()
	filenamePath := ""

	// Scan all files passed in command line.
	for _, filename := range flag.Args() {
		switch info, err := os.Stat(filename); {
		case err != nil:
			log.Print(err)
			exitCode = 1
		case info.Mode()&os.ModeType == 0: // regular file
			if err := processFile(filename, proto); err != nil {
				log.Printf("\t%s\n\n", filename)
				scanner.PrintError(os.Stderr, err)
				exitCode = 1
			} else if filename == "" {
				filenamePath = filename
			}
		default:
			log.Print("not regular file: ", filename)
			exitCode = 1
		}
	}
	if exitCode != 0 {
		os.Exit(exitCode)
	}

	// Find in header files
	if errList := proto.find(); errList != nil {
		for _, e := range errList {
			log.Print(e)
		}
		os.Exit(1)
	}
	if len(proto.includes) == 0 {
		log.Print("prototypes not found")
		os.Exit(1)
	}

	// Create file
	var err error
	filew := os.Stdout
	if *Write {
		filew, err = os.Create(filepath.Join(filepath.Dir(filenamePath),
			fmt.Sprintf("z-sys_%s_%s.go", runtime.GOOS, runtime.GOARCH)))
		if err != nil {
			log.Fatal(err)
		}
		defer func() {
			if err = filew.Close(); err != nil {
				log.Print(err)
			}
		}()
	}

	sort.Strings(proto.includes)
	sort.Strings(proto.enums)
	sort.Strings(proto.structs)
	sort.Strings(proto.unions)

	// Return '_' for constants not exported.
	exportConst := func(name string) string {
		v, found := proto.export[name]
		if found {
			if !v {
				return "_"
			}
		} else if !*Export {
			return "_"
		}
		return ""
	}

	// Return the name in title case if it is exported.
	exportIdent := func(name string) string {
		v, found := proto.export[name]
		if found {
			if !v {
				return name
			}
		} else if !*Export {
			return name
		}
		return strings.Title(name)
	}

	// Write

	HEADER = fmt.Sprintf("// %s\n%s", strings.Join(os.Args, " "), HEADER)

	buftext := new(bytes.Buffer)
	buftext.WriteString(HEADER)
	buftext.WriteString("\npackage " + proto.pkgName + "\n\n")

	for _, v := range proto.includes {
		buftext.WriteString(fmt.Sprintf("// #include <%s>\n", v))
	}
	buftext.WriteString("import \"C\"\n")

	for _, group := range proto.consts {
		// Get the comment for the constant
		if group[0] != "" {
			buftext.WriteString("\n" + group[0])
		}
		group = group[1:]

		sort.Strings(group)

		if len(group) > 1 {
			buftext.WriteString("\nconst (\n")

			for _, v := range group {
				goIdent := exportConst(v)

				if newGoIdent, found := proto.newIdent[v]; found {
					goIdent += newGoIdent
				} else {
					goIdent += v
				}
				buftext.WriteString(fmt.Sprintf("\t%s = C.%s\n", goIdent, v))
			}
			buftext.WriteString(")\n")

		} else if len(group) == 1 {
			cIdent := group[0]
			goIdent := exportConst(cIdent)

			if newGoIdent, found := proto.newIdent[cIdent]; found {
				goIdent += newGoIdent
			} else {
				goIdent += cIdent
			}

			buftext.WriteString(fmt.Sprintf("\nconst %s = C.%s\n", goIdent, cIdent))
		}
	}

	for _, v := range proto.enums {
		buftext.WriteString(fmt.Sprintf("\ntype %s C.enum_%s\n", exportIdent(v), v))
	}
	for _, v := range proto.structs {
		buftext.WriteString(fmt.Sprintf("\ntype %s C.struct_%s\n", exportIdent(v), v))
	}
	for _, v := range proto.unions {
		buftext.WriteString(fmt.Sprintf("\ntype %s C.union_%s\n", exportIdent(v), v))
	}

	// Temporary file to be used by cgo
	f, err := os.Create(filepath.Join(filepath.Dir(filenamePath),
		fmt.Sprintf("_z-sys_%s_%s.go", runtime.GOOS, runtime.GOARCH)))
	if err != nil {
		log.Fatal(err)
	}
	if _, err = f.Write(buftext.Bytes()); err != nil {
		log.Fatal(err)
	}
	f.Close()

	if *Debug {
		if *Write {
			fmt.Println(f.Name())
		} else {
			filew.Write(buftext.Bytes())
			os.Remove(f.Name())
		}
		os.Exit(0)
	}
	defer func() {
		if err = os.Remove(f.Name()); err != nil {
			log.Print(err)
		}
	}()

	cmd := exec.Command("go", "tool", "cgo", "-godefs", f.Name())
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatal(err)
	}
	os.RemoveAll("_obj") // directory created by 'go tool cgo'

	out = append(out[:0], append([]byte(HEADER+"//\n"), out[0:]...)...)

	if out, err = format.Source(out); err != nil {
		log.Fatal(err)
	}
	if _, err = filew.Write(out); err != nil {
		log.Fatal(err)
	}
}

func processFile(filename string, proto *prototype) error {
	info, err := os.Stat(filename)
	if err != nil {
		return err
	}
	src, err := os.ReadFile(filename)
	if err != nil {
		return err
	}

	// Scan file

	var errorList scanner.ErrorList
	var s scanner.Scanner
	fset := token.NewFileSet()
	file := fset.AddFile(filename, fset.Base(), int(info.Size()))
	s.Init(file, src, nil, scanner.ScanComments)

	for findPkg, isPkgToken := true, false; ; {
		_, tok, lit := s.Scan()
		if tok == token.EOF {
			break
		}

		// package name
		if findPkg {
			if tok == token.PACKAGE {
				isPkgToken = true
				continue
			}
			if isPkgToken {
				if proto.pkgName == "" {
					(*proto).pkgName = lit
				} else if proto.pkgName != lit {
					return errors.New("the files have different package name")
				}
				findPkg = false
				continue
			}
		}

		// scan comments

		if tok != token.COMMENT || !strings.HasPrefix(lit, PREFIX) {
			continue
		}

		lit = strings.Replace(lit, PREFIX, "", 1)
		if lit[0] == '/' && lit[1] == '/' {
			proto.comment = lit
			continue
		}
		if lit[0] != ' ' && lit[0] != '\t' {
			continue
		}
		lit_ := strings.TrimSpace(lit)

		// multiple comments
		for {
			if lit[len(lit)-1] == ',' { // the line continues on the next one
				_, tok, lit = s.Scan()
				if tok == token.COMMENT {
					lit = strings.Replace(lit, "//", "", 1)
					lit = strings.TrimSpace(lit)
					lit_ += lit
				} else {
					break
				}
			} else {
				break
			}
		}

		err := scanProtype(proto, []byte(lit_))
		if err != nil {
			errorList.Add(err.Pos, err.Msg)
			continue
		}
	}
	if errorList.Len() != 0 {
		return errorList
	}
	return nil
}

// == Parser
//

func scanProtype(p *prototype, src []byte) (err *scanner.Error) {
	var s scanner.Scanner
	fset := token.NewFileSet()
	file := fset.AddFile("", fset.Base(), len(src))
	s.Init(file, src, nil, 0)

	var newExport, export bool
	errMsg := ""
	pos, tok, lit := s.Scan()

	// Export
	if tok == token.LBRACK {
		pos, tok, lit = s.Scan()
		if tok != token.IDENT || lit != "export" {
			errMsg = "expected identifier export"
			goto _error
		}

		pos, tok, lit = s.Scan()
		if tok != token.ASSIGN {
			errMsg = "expected assignment sign"
			goto _error
		}

		pos, tok, lit = s.Scan()
		if tok != token.IDENT || (lit != "true" && lit != "false") {
			errMsg = "expected boolean value"
			goto _error
		}
		export, _ = strconv.ParseBool(lit)
		newExport = true

		pos, tok, lit = s.Scan()
		if tok != token.RBRACK {
			errMsg = "expected right bracket"
			goto _error
		}

		pos, tok, lit = s.Scan()
	}

	if tok == token.CONST {
		pos, tok, lit = s.Scan()
		consts := make([]string, 0)

		// The first field is the comment, if any
		consts = append(consts, p.comment)
		p.comment = ""

		if tok == token.LPAREN { // multiple constant
			for {
				pos, tok, lit = s.Scan()
				if tok != token.IDENT {
					errMsg = "expected identifier"
					goto _error
				}
				consts = append(consts, lit)
				if newExport {
					p.export[lit] = export
				}

				pos, tok, lit = s.Scan()
				if tok == token.RPAREN {
					break
				} else if tok == token.COMMA {
					continue
				} else if tok == token.IDENT {
					errMsg = "expected comma"
					goto _error
				} else {
					errMsg = "expected right parenthesis"
					goto _error
				}
			}
		} else if tok == token.IDENT { // single constant
			_, tok, _ = s.Scan()

			if tok == token.COMMA || tok == token.RPAREN {
				errMsg = "expected left parenthesis"
				goto _error
			} else if tok != token.ASSIGN && tok != token.EOF && tok != token.SEMICOLON {
				errMsg = "expected to finish"
				goto _error
			}
			goIdent := lit

			if tok == token.ASSIGN {
				pos, tok, lit = s.Scan()
				if tok != token.IDENT {
					errMsg = "expected identifier after of assignment sign"
					goto _error
				}

				p.newIdent[lit] = goIdent
				consts = append(consts, lit)
				if newExport {
					p.export[lit] = export
				}
			} else {
				consts = append(consts, goIdent)
				if newExport {
					p.export[goIdent] = export
				}
			}

		} else {
			errMsg = "expected identifier"
			goto _error
		}
		p.consts = append(p.consts, consts)

	} else if tok == token.TYPE {
		pos, tok, lit = s.Scan()
		if tok != token.IDENT {
			errMsg = "expected identifier"
			goto _error
		}

		prefix := strings.SplitN(lit, "_", 2)
		if len(prefix) != 2 {
			errMsg = "expected type prefix"
			goto _error
		}

		switch prefix[0] {
		case "enum":
			p.enums = append(p.enums, prefix[1])
		case "struct":
			p.structs = append(p.structs, prefix[1])
		case "union":
			p.unions = append(p.unions, prefix[1])
		default:
			errMsg = "expected valid type prefix"
			goto _error
		}

		if newExport {
			p.export[prefix[1]] = export
		}

	} else {
		if lit == "export" {
			errMsg = "expected left bracket"
		} else {
			errMsg = "identifier: expected const or type"
		}
		goto _error
	}

	// End?
	pos, tok, lit = s.Scan()
	if tok != token.SEMICOLON && tok != token.EOF {
		errMsg = "expected to finish"
		goto _error
	}
	return nil

_error:
	if lit == "" {
		lit = tok.String()
	}
	return &scanner.Error{
		fset.Position(pos),
		fmt.Sprintf("%s\n    + %s, got %q\n", src, errMsg, lit),
	}
}

// * * *

type prototype struct {
	pkgName  string
	comment  string
	consts   [][]string
	enums    []string
	structs  []string
	unions   []string
	includes []string

	newIdent map[string]string // C ident: Go ident
	export   map[string]bool
}

func NewPrototype() *prototype {
	return &prototype{
		"",
		"",
		make([][]string, 0),
		make([]string, 0),
		make([]string, 0),
		make([]string, 0),
		make([]string, 0),
		make(map[string]string),
		make(map[string]bool),
	}
}

// == Find header files
//

// find finds the constants and types in directory of headers according to the
// operating system.
func (p *prototype) find() []error {
	errorList := make([]error, 0)

	dir := "/usr/include/"
	if runtime.GOOS == "windows" {
		dir = filepath.Join(*WinGCC, `include\`)
	}

	isOnIncludes := func(find *regexp.Regexp) bool {
		for _, f := range p.includes {
			found, _ := Match(f, find)
			if found {
				return true
			}
		}
		return false
	}

	AddInclude := func(name, val string, re *regexp.Regexp) {
		headerFile, err := FindDir(dir, re)
		if err != nil {
			errorList = append(errorList, err...)
		} else if headerFile == "" {
			errorList = append(errorList, fmt.Errorf("could not find %s %s", name, val))
		} else {
			p.includes = append(p.includes, headerFile)
		}
	}

	for _, group := range p.consts {
		for _, v := range group[1:] {
			re := regexp.MustCompile(fmt.Sprintf(
				"^#[ \t]*(define|DEFINE)[ \t]+(%s)[ \t]+", v))

			if isOnIncludes(re) {
				continue
			}
			AddInclude("constant", v, re)
		}
	}
	for _, v := range p.enums {
		re := regexp.MustCompile(fmt.Sprintf(
			"^[ \t]*(enum)[ \t]+(%s)[ \t]+{", v))

		if isOnIncludes(re) {
			continue
		}
		AddInclude("enum", v, re)
	}
	for _, v := range p.structs {
		re := regexp.MustCompile(fmt.Sprintf(
			"^[ \t]*(struct)[ \t]+(%s)[ \t]+{", v))

		if isOnIncludes(re) {
			continue
		}
		AddInclude("struct", v, re)
	}
	for _, v := range p.unions {
		re := regexp.MustCompile(fmt.Sprintf(
			"^[ \t]*(union)[ \t]+(%s)[ \t]+{", v))

		if isOnIncludes(re) {
			continue
		}
		AddInclude("union", v, re)
	}

	if len(errorList) != 0 {
		return errorList
	}

	for i, v := range p.includes {
		p.includes[i] = strings.Replace(v, dir, "", 1)
	}
	return nil
}

func Match(filename string, find *regexp.Regexp) (bool, error) {
	f, err := os.Open(filename)
	if err != nil {
		return false, fmt.Errorf("Match: %s", err)
	}
	defer f.Close()

	buf := bufio.NewReader(f)

	for {
		line, err := buf.ReadBytes('\n')
		if err == io.EOF {
			break
		}
		if find.Match(line) {
			return true, nil
		}
	}
	return false, nil
}

var errFound = errors.New("found")

func FindDir(path string, find *regexp.Regexp) (string, []error) {
	var headerFile string
	var pHeader = &headerFile
	errorCh := make(chan error)
	errorList := make([]error, 0)
	done := make(chan bool)

	// Error handler
	go func() {
		for err := range errorCh {
			if err != nil && err != errFound {
				errorList = append(errorList, err)
			}
		}
		done <- true
	}()

	filepath.Walk(path, walkFn(find, pHeader, errorCh))
	close(errorCh)
	<-done

	if len(errorList) == 0 {
		return headerFile, nil
	}
	return "", errorList
}

// walkFn implements filepath.WalkFunc
func walkFn(find *regexp.Regexp, pHeader *string, errorCh chan error) filepath.WalkFunc {
	return func(path string, info os.FileInfo, err error) error {
		if err != nil {
			errorCh <- err
			return nil
		}

		// Is header?
		name := info.Name()
		if !info.IsDir() && strings.HasSuffix(name, ".h") &&
			(unicode.IsLetter(rune(name[0])) || name[0] == '_') {

			found, err := Match(path, find)
			if found == true {
				*pHeader = path
				return errFound
			}
			if err != nil {
				errorCh <- err
			}
			return nil
		}
		return nil
	}
}
