// Copyright 2012 Jonas mg
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
Command go.mksyscall reads a file containing function prototypes and generates
system call bodies.
The prototypes are marked by lines beginning with "// +sys"
and read like func declarations if "// +sys" is replaced by "func", but:

	* If Go function name needs to be different from it's winapi dll name,
	  the winapi name could be specified at the end, after "=" sign, like
	  // +sys LoadLibrary(libname string) (handle uint32, err error) = LoadLibraryA
	* If the winapi dll ends into a "W", like
	  // +sys LoadLibrary(libname string) (handle uint32, err error) = LoadLibraryW
	  then the strings are passed like unicode instead of ascii.

	* The parameter lists must give a name for each argument.
	  This includes return parameters.
	* The parameter lists must give a type for each argument:
	  the (x, y, z int) shorthand is not allowed.
	* At converting types, if a parameter is a struct, it can be prefixed with
	'_' allowing the usage of private structs.

	* If the return parameter is an error number, it must be named err.
	* Each function that returns err needs to supply a condition;
	  that return value of winapi will be tested against to detect failure.
	  This would set err to windows "last-error", otherwise it will be nil.
	  The value can be provided at end of "// +sys" declaration, like
	  // +sys LoadLibrary(libname string) (handle uint32, err error) [failretval==-1]
	  = LoadLibraryA and is [failretval==0] by default.

When the ouput is written to file (flag -w), the name of the file generated is
"z-syscall_", adding the system and the architecture when it is necessary.

The flag -conv does conversion from Windows types to Go. If it shows some
failure is because it has not beed added; check function WinToGo.

The flag -lazy to enable to use the function MustLoadDLL or NewLazyDLL (by
default).
To read the documentation related to those functions (http://golang.org/src/pkg/syscall/dll_windows.go):

  godoc syscall MustLoadDLL [NewLazyDLL]
*/
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"go/scanner"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

const (
	HEADER = "// MACHINE GENERATED BY go.mksyscall (github.com/tredoe/goutil/go.mksyscall); DO NOT EDIT\n\n"
	PREFIX = "// +sys"
)

var validSystems = []string{"windows"}

// Flags
var (
	IsLazy    = flag.Bool("lazy", true, "use LazyDLL in Windows to load the DLL")
	IsLEndian = flag.Bool("l32", true, "little-endian (false for big-endian)")
	IsConv    = flag.Bool("conv", true, "conversion of types")
	IsToWrite = flag.Bool("w", false, "write output to file")
	System    = flag.String("os", "windows", "operating system")

	ListSystems = flag.Bool("ls.os", false, "list of valid systems")
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: go.mksyscall [-w] file...
Generate Go functions from prototypes to access to system calls.

`)
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	flag.Usage = usage
	flag.Parse()

	if *ListSystems {
		fmt.Print("  = Systems\n  ")
		fmt.Println(validSystems)
		os.Exit(0)
	}
	if len(os.Args) == 1 || *System == "" {
		usage()
	}

	log.SetFlags(0)
	log.SetPrefix("FAIL! ")

	var isSystem bool
	*System = strings.ToLower(*System)

	for _, v := range validSystems {
		if v == *System {
			isSystem = true
			break
		}
	}
	if !isSystem {
		log.Fatal("system passed in flag -s is invalid")
	}

	exitCode := 0
	protos := make([]*prototype, 0)

	// Scan all files passed in command line.
	for _, filename := range flag.Args() {
		switch info, err := os.Stat(filename); {
		case err != nil:
			log.Print(err)
			exitCode = 1
		case info.Mode()&os.ModeType == 0: // regular file
			if p, err := processFile(filename); err != nil {
				log.Printf("\t%s\n\n", filename)
				scanner.PrintError(os.Stderr, err)
				exitCode = 1
			} else {
				protos = append(protos, p...)
			}
		default:
			log.Print("not regular file: ", filename)
			exitCode = 1
		}
	}
	if len(protos) == 0 {
		log.Print("prototypes not found")
		exitCode = 1
	}
	if exitCode != 0 {
		os.Exit(exitCode)
	}

	// Modules and procedures

	var useInt64 bool
	mods := make([]string, 0)
	procs := make([]string, len(protos))

	for i, p := range protos {
		found := false

		if !useInt64 && p.useInt64 {
			useInt64 = true
		}

		if p.modName == "" {
			p.modName = "kernel32"
		}

		for _, v := range MOD_NAMES {
			if v == p.modName {
				found = true
				break
			}
		}
		if !found {
			MOD_NAMES = append(MOD_NAMES, p.modName)
			if *IsLazy {
				mods = append(mods, fmt.Sprintf("mod%s = %sNewLazyDLL(\"%s.dll\")",
					p.modName, SYSCALL_DOT, p.modName))
			} else {
				mods = append(mods, fmt.Sprintf("mod%s = %sMustLoadDLL(\"%s.dll\")",
					p.modName, SYSCALL_DOT, p.modName))
			}
		}

		winFuncName := p.winFuncName
		if winFuncName == "" {
			winFuncName = p.goFuncName
		}
		if *IsLazy {
			procs[i] = fmt.Sprintf("proc%s = mod%s.NewProc(\"%s\")",
				p.winFuncName, p.modName, winFuncName)
		} else {
			procs[i] = fmt.Sprintf("proc%s = mod%s.MustFindProc(\"%s\")",
				p.winFuncName, p.modName, winFuncName)
		}
	}

	// Create file

	var err error
	var filew, filew32, filew64 *os.File

	if *IsToWrite {
		_file := "z-syscall_" + *System

		if filew, err = os.Create(_file + ".go"); err != nil {
			log.Fatal(err)
		}
		defer func() {
			if err = filew.Close(); err != nil {
				log.Print(err)
			}
		}()

		if useInt64 {
			if filew32, err = os.Create(_file + "_386.go"); err != nil {
				log.Fatal(err)
			}
			defer func() {
				if err = filew32.Close(); err != nil {
					log.Print(err)
				}
			}()

			if filew64, err = os.Create(_file + "_amd64.go"); err != nil {
				log.Fatal(err)
			}
			defer func() {
				if err = filew64.Close(); err != nil {
					log.Print(err)
				}
			}()
		}
	} else {
		filew = os.Stdout
		filew32 = os.Stdout
		filew64 = os.Stdout
	}

	// Write

	var useUnsafe, useUnsafe_arch bool
	buftext := new(bytes.Buffer)
	buftext32 := new(bytes.Buffer)
	buftext64 := new(bytes.Buffer)

	import1 := "import \"syscall\"\n\n"
	importUnsafe := "import (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n"

	if SYSCALL_DOT == "" {
		import1 = ""
		importUnsafe = "import \"unsafe\"\n\n"
	}

	bufheader := new(bytes.Buffer)
	bufheader.WriteString("// " + strings.Join(os.Args, " ") + "\n")
	bufheader.WriteString(HEADER)

	buftext.WriteString("var (\n")
	for _, m := range mods {
		buftext.WriteString("\t" + m + "\n")
	}
	buftext.WriteString("\n")
	for _, p := range procs {
		buftext.WriteString("\t" + p + "\n")
	}
	buftext.WriteString(")\n")

	if err = formatVar(buftext); err != nil {
		log.Fatal(err)
	}

	for _, p := range protos {
		buffunc := new(bytes.Buffer)
		buffunc.WriteString(fmt.Sprintf("func %s(%s) (%s) {\n",
			p.goFuncName, p.getArgs("in"), p.getArgs("out")))

		vars, syscallArgs, syscallArgs_32b, syscallArgs_64b := p.getSyscallArgs()
		body, ret := p.getRetValues()

		if p.useUnsafe {
			if p.useInt64 {
				useUnsafe_arch = true
			} else {
				useUnsafe = true
			}
		}

		textRet := ""
		if ret[0] != "_" || ret[1] != "_" || ret[2] != "_" {
			textRet = fmt.Sprintf("%s, %s, %s := ", ret[0], ret[1], ret[2])
		}

		if vars != "" {
			buffunc.WriteString(vars)
		}

		if p.useInt64 {
			buftext32.Write(buffunc.Bytes())

			buftext32.WriteString(fmt.Sprintf("\t%s%s(%s)\n",
				textRet, syscallArgs_32b[0], strings.Join(syscallArgs_32b[1:], ", ")))

			buftext32.WriteString(body)
			buftext32.WriteString("\treturn\n")
			buftext32.WriteString("}\n")

			// amd64
			buftext64.Write(buffunc.Bytes())
			buftext64.WriteString(fmt.Sprintf("\t%s%s(%s)\n",
				textRet, syscallArgs_64b[0], strings.Join(syscallArgs_64b[1:], ", ")))

			buftext64.WriteString(body)
			buftext64.WriteString("\treturn\n")
			buftext64.WriteString("}\n")
		} else {
			buftext.Write([]byte{'\n'})
			buftext.Write(buffunc.Bytes())

			buftext.WriteString(fmt.Sprintf("\t%s%s(%s)\n",
				textRet, syscallArgs[0], strings.Join(syscallArgs[1:], ", ")))

			buftext.WriteString(body)
			buftext.WriteString("\treturn\n")
			buftext.WriteString("}\n")
		}
	}

	if _, err = filew.Write(bufheader.Bytes()); err != nil {
		log.Fatal(err)
	}
	filew.WriteString("package " + PKG_NAME + "\n\n")

	if useUnsafe {
		filew.WriteString(importUnsafe)
	} else {
		filew.WriteString(import1)
	}
	if _, err = filew.Write(buftext.Bytes()); err != nil {
		log.Fatal(err)
	}

	// File per architecture

	if buftext32.Len() != 0 {
		if _, err = filew32.Write(bufheader.Bytes()); err != nil {
			log.Fatal(err)
		}
		filew32.WriteString("package " + PKG_NAME + "\n\n")

		if useUnsafe_arch {
			filew32.WriteString(importUnsafe)
		} else {
			filew32.WriteString(import1)
		}
		if _, err = filew32.Write(buftext32.Bytes()); err != nil {
			log.Fatal(err)
		}

		// AMD64
		if _, err = filew64.Write(bufheader.Bytes()); err != nil {
			log.Fatal(err)
		}
		filew64.WriteString("package " + PKG_NAME + "\n\n")

		if useUnsafe_arch {
			filew64.WriteString(importUnsafe)
		} else {
			filew64.WriteString(import1)
		}
		if _, err = filew64.Write(buftext64.Bytes()); err != nil {
			log.Fatal(err)
		}
	}

}

var (
	// To avoid repeat the same definition of modules in several files.
	MOD_NAMES   = make([]string, 0)
	PKG_NAME    = ""
	SYSCALL_DOT = "syscall."
)

func processFile(filename string) ([]*prototype, error) {
	info, err := os.Stat(filename)
	if err != nil {
		return nil, err
	}
	src, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// Scan file

	protos := make([]*prototype, 0)

	var errorList scanner.ErrorList
	var s scanner.Scanner
	fset := token.NewFileSet()
	file := fset.AddFile(filename, fset.Base(), int(info.Size()))
	s.Init(file, src, nil, scanner.ScanComments)

	for findPkg, isPkgToken := true, false; ; {
		_, tok, lit := s.Scan()
		if tok == token.EOF {
			break
		}

		// package name
		if findPkg {
			if tok == token.PACKAGE {
				isPkgToken = true
				continue
			}
			if isPkgToken {
				if PKG_NAME == "" {
					PKG_NAME = lit
					if PKG_NAME == "syscall" {
						SYSCALL_DOT = ""
					}
				} else if PKG_NAME != lit {
					return nil, errors.New("the files have different package name")
				}
				findPkg = false
				continue
			}
		}

		// scan comments

		if tok != token.COMMENT || !strings.HasPrefix(lit, PREFIX) {
			continue
		}
		lit = strings.Replace(lit, PREFIX, "", 1)
		if lit[0] != ' ' && lit[0] != '\t' {
			continue
		}
		lit = strings.TrimSpace(lit)

		proto, err := scanProtype([]byte(lit))
		if err != nil {
			errorList.Add(err.Pos, err.Msg)
			continue
		}

		if errorList.Len() == 0 {
			protos = append(protos, proto)
		}
	}
	if errorList.Len() != 0 {
		return nil, errorList
	}
	return protos, nil
}

// == Parser
//

type prototype struct {
	useInt64  bool
	useUnsafe bool

	goFuncName  string
	failCond    string
	modName     string // Dll file name; by default to kernel32
	winFuncName string
	inParams    []param
	outParams   []param
}

func (p *prototype) getArgs(s string) string {
	args := new(bytes.Buffer)

	var params []param

	if s == "in" {
		params = p.inParams
	} else if s == "out" {
		params = p.outParams
	} else {
		panic("getArgs: wrong argument: " + s)
	}

	for i, v := range params {
		if i != 0 {
			args.WriteString(", ")
		}
		args.WriteString(v.name + " " + v._type)
	}
	return args.String()
}

// getRetValues prepares the return values.
func (p *prototype) getRetValues() (body string, ret [3]string) {
	ret = [3]string{"_", "_", "_"}
	bufbody := new(bytes.Buffer)
	reg := ""
	failExpr := ""

	for i, v := range p.outParams {
		if v.name == "err" {
			reg = "e1"
			ret[2] = reg
		} else {
			reg = fmt.Sprintf("r%d", i)
			ret[i] = reg
		}

		if v._type == "bool" {
			reg += " != 0"
		} else if v._type == "int64" {
			// 64-bit number in r1:r0 or r0:r1.
			if i+2 > len(p.outParams) {
				log.Fatalf("not enough registers for int64 return: %v", p.outParams)
			}
			if *IsLEndian {
				reg = fmt.Sprintf("int64(r%d)<<32 | int64(r%d)", i+1, i)
			} else {
				reg = fmt.Sprintf("int64(r%d)<<32 | int64(r%d)", i, i+1)
			}
			ret[i] = fmt.Sprintf("r%d", i)
			ret[i+1] = fmt.Sprintf("r%d", i+1)
		}

		retType := v._type
		if retType[0] == '*' {
			reg = fmt.Sprintf("unsafe.Pointer(%s)", reg)
			retType = fmt.Sprintf("(%s)", retType)
		}

		if i == 0 {
			if v._type == "bool" {
				failExpr = "!" + v.name
			} else if v.name == "err" {
				ret[0] = "r1"
				failExpr = "int(r1) " + p.failCond
			} else {
				failExpr = v.name + " " + p.failCond
			}
		}

		if v.name == "err" {
			// Set err to "last error" only if returned value indicate failure
			bufbody.WriteString(fmt.Sprintf("\tif %s {\n", failExpr))
			bufbody.WriteString(fmt.Sprintf("\t\tif %s != 0 {\n", reg))
			bufbody.WriteString(fmt.Sprintf("\t\t\t%s = %s(%s)\n", v.name, v._type, reg))
			bufbody.WriteString(fmt.Sprintf("\t\t} else {\n"))
			bufbody.WriteString(fmt.Sprintf("\t\t\t%s = %sEINVAL\n", v.name, SYSCALL_DOT))
			bufbody.WriteString(fmt.Sprintf("\t\t}\n"))
			bufbody.WriteString(fmt.Sprintf("\t}\n"))
		} else if retType == "error" {
			// Set reg to "error" only if returned value indicate failure
			bufbody.WriteString(fmt.Sprintf("\tif %s != 0 {\n", reg))
			bufbody.WriteString(fmt.Sprintf("\t\t%s = %sErrno(%s)\n", v.name, SYSCALL_DOT, reg))
			bufbody.WriteString("\t}\n")
		} else {
			bufbody.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", v.name, retType, reg))
		}
	}

	return bufbody.String(), ret
}

// getSyscallArgs prepares arguments to Syscall.
func (p *prototype) getSyscallArgs() (vars string, syscallArgs, syscallArgs_32b, syscallArgs_64b []string) {
	var v1, v2 string
	n := 0

	// Decide which version of api is used: ascii or unicode.
	strconvfunc := "StringBytePtr"
	if p.winFuncName[len(p.winFuncName)-1] == 'W' {
		strconvfunc = "StringToUTF16Ptr"
	}

	for _, v := range p.inParams {
		if v._type[0] == '*' {
			p.useUnsafe = true
			v1 = fmt.Sprintf("uintptr(unsafe.Pointer(%s))", v.name)

			syscallArgs = append(syscallArgs, v1)
			syscallArgs_32b = append(syscallArgs_32b, v1)
			syscallArgs_64b = append(syscallArgs_64b, v1)

		} else if v._type == "string" {
			p.useUnsafe = true
			v1 = fmt.Sprintf("uintptr(unsafe.Pointer(%s%s(%s)))",
				SYSCALL_DOT, strconvfunc, v.name)

			syscallArgs = append(syscallArgs, v1)
			syscallArgs_32b = append(syscallArgs_32b, v1)
			syscallArgs_64b = append(syscallArgs_64b, v1)

		} else if strings.HasPrefix(v._type, "[]") && len(v._type) > 2 {
			// Convert slice into pointer, length.
			// Have to be careful not to take address of &a[0] if len == 0:
			// pass nil in that case.

			vars += fmt.Sprintf("\tvar _p%d *%s\n", n, v._type[2:])
			vars += fmt.Sprintf("\tif len(%s) > 0 {\n\t\t_p%d = &%s[0]\n\t}\n",
				v.name, n, v.name)

			p.useUnsafe = true
			v1 = fmt.Sprintf("uintptr(unsafe.Pointer(_p%d))", n)
			v2 = fmt.Sprintf("uintptr(len(%s))", v.name)
			n++

			syscallArgs = append(syscallArgs, v1)
			syscallArgs_32b = append(syscallArgs_32b, v1)
			syscallArgs_64b = append(syscallArgs_64b, v1)
			syscallArgs = append(syscallArgs, v2)
			syscallArgs_32b = append(syscallArgs_32b, v2)
			syscallArgs_64b = append(syscallArgs_64b, v2)

		} else if v._type == "int64" {
			p.useInt64 = true
			syscallArgs_64b = append(syscallArgs_64b, fmt.Sprintf("uintptr(%s)", v.name))

			if *IsLEndian {
				syscallArgs_32b = append(syscallArgs_32b, fmt.Sprintf("uintptr(%s)", v.name))
				syscallArgs_32b = append(syscallArgs_32b, fmt.Sprintf("uintptr(%s >> 32)", v.name))
			} else {
				syscallArgs_32b = append(syscallArgs_32b, fmt.Sprintf("uintptr(%s >> 32)", v.name))
				syscallArgs_32b = append(syscallArgs_32b, fmt.Sprintf("uintptr(%s)", v.name))
			}

		} else if v._type == "bool" {
			vars += fmt.Sprintf("\tvar _p%d uint32\n", n)
			vars += fmt.Sprintf("\tif %s {\n\t\t_p%d = 1\n\t} else {\n\t\t_p%d = 0\n\t}\n",
				v.name, n, n)

			v1 = fmt.Sprintf("uintptr(_p%d)", n)
			n++

			syscallArgs = append(syscallArgs, v1)
			syscallArgs_32b = append(syscallArgs_32b, v1)
			syscallArgs_64b = append(syscallArgs_64b, v1)

		} else {
			v1 = fmt.Sprintf("uintptr(%s)", v.name)

			syscallArgs = append(syscallArgs, v1)
			syscallArgs_32b = append(syscallArgs_32b, v1)
			syscallArgs_64b = append(syscallArgs_64b, v1)
		}
	}

	// Determine which form to use; pad args with zeros.

	getCallName := func(nargs int, args *[]string) string {
		call := SYSCALL_DOT + "Syscall"

		if nargs <= 15 {
			for i, n := range []int{3, 6, 9, 12, 15} {
				if nargs <= n {
					for ; nargs < n; nargs++ {
						*args = append(*args, "0")
					}
					if i != 0 {
						call += strconv.Itoa(n)
					}
					break
				}
			}
		} else {
			log.Fatal("too many arguments to system call")
		}

		return call
	}

	call := fmt.Sprintf("proc%s.Addr()", p.winFuncName) // Actual call

	if !p.useInt64 {
		syscallArgs_32b = nil
		syscallArgs_64b = nil
		nargs := len(syscallArgs) // Number of arguments

		tmp := []string{getCallName(nargs, &syscallArgs), call, strconv.Itoa(nargs)}
		syscallArgs = append(syscallArgs[:0],
			append(tmp, syscallArgs[0:]...)...)
	} else {
		syscallArgs = nil
		nargs32b := len(syscallArgs_32b)
		nargs64b := len(syscallArgs_64b)

		tmp := []string{
			getCallName(nargs32b, &syscallArgs_32b),
			call,
			strconv.Itoa(nargs32b),
		}
		syscallArgs_32b = append(syscallArgs_32b[:0],
			append(tmp, syscallArgs_32b[0:]...)...)

		tmp = []string{
			getCallName(nargs64b, &syscallArgs_64b),
			call,
			strconv.Itoa(nargs64b),
		}
		syscallArgs_64b = append(syscallArgs_64b[:0],
			append(tmp, syscallArgs_64b[0:]...)...)
	}

	return
}

// scanProtype splits a prototype line into name, in params, out params,
// and optional error condition and windows API name.
//
// Line must be of the form:
//   GoFunction(arg string) (handle uint32, err error)
//
// Optional:
//   [failretval==-1]
//   = library.WinFunction
//
// Note: "Library." is optional, using kernel32 by default
func scanProtype(src []byte) (proto *prototype, err *scanner.Error) {
	var s scanner.Scanner
	fset := token.NewFileSet()
	file := fset.AddFile("", fset.Base(), len(src))
	s.Init(file, src, nil, 0)

	errMsg := ""
	proto = new(prototype)

	pos, tok, lit := s.Scan()
	// Go name
	if tok != token.IDENT {
		errMsg = "Go function name: expected identifier"
		goto _error
	}
	proto.goFuncName = lit
	pos, tok, lit = s.Scan()

	// In parameters
	if tok != token.LPAREN {
		errMsg = "in parameters: expected left parenthesis"
		goto _error
	}

	if proto.inParams, err = parseParam(&s, fset, true); err != nil {
		err.Msg = fmt.Sprintf("%s\n    + %s\n", src, err.Msg)
		return nil, err
	}

	pos, tok, lit = s.Scan()
	// Optional out parameters
	if tok == token.LPAREN {
		if proto.outParams, err = parseParam(&s, fset, false); err != nil {
			err.Msg = fmt.Sprintf("%s\n    + %s\n", src, err.Msg)
			return nil, err
		}
		pos, tok, lit = s.Scan()
	}

	// Optional error condition; returned value when failed
	if tok == token.LBRACK {
		if pos, tok, lit = s.Scan(); tok != token.IDENT || lit != "failretval" {
			errMsg = "error condition: expected identifier failretval"
			goto _error
		}

		pos, tok, lit = s.Scan()
		if tok == token.AND || tok == token.OR || tok == token.XOR || tok == token.AND_NOT {
			proto.failCond = tok.String()
			pos, tok, lit = s.Scan()
			if tok != token.INT {
				errMsg = "error condition: expected integer in bitwise operation"
				goto _error
			}
			proto.failCond += lit
			pos, tok, lit = s.Scan()
		}
		if tok != token.EQL && tok != token.NEQ {
			errMsg = "error condition: expected comparison operator"
			goto _error
		}

		proto.failCond += tok.String() + " "
		pos, tok, lit = s.Scan()

		if tok == token.SUB {
			proto.failCond += token.SUB.String()
			pos, tok, lit = s.Scan()
		}
		if tok != token.INT && tok != token.IDENT {
			errMsg = "error condition: expected integer or identifier"
			goto _error
		}
		proto.failCond += lit

		if pos, tok, lit = s.Scan(); tok != token.RBRACK {
			errMsg = "error condition: expected right bracket"
			goto _error
		}

		pos, tok, lit = s.Scan()
	} else {
		proto.failCond = "== 0"
	}

	// Optional Dll / winapi name
	if tok == token.ASSIGN {
		pos, tok, lit = s.Scan()
		if tok != token.IDENT {
			errMsg = "Dll or Win API name: expected identifier"
			goto _error
		}
		proto.winFuncName = lit

		pos, tok, lit = s.Scan()
		if tok == token.PERIOD {
			pos, tok, lit = s.Scan()
			if tok != token.IDENT {
				errMsg = "Win API name: expected identifier"
				goto _error
			}
			proto.modName = proto.winFuncName
			proto.winFuncName = lit
			pos, tok, lit = s.Scan()
		}
	} else {
		proto.winFuncName = proto.goFuncName
	}

	// End?
	if tok == token.IDENT {
		errMsg = "expected equal sign"
		goto _error
	} else if tok != token.SEMICOLON {
		errMsg = "expected to finish"
		goto _error
	}
	return proto, nil

_error:
	if lit == "" {
		lit = tok.String()
	}
	return proto, &scanner.Error{
		fset.Position(pos),
		fmt.Sprintf("%s\n    + %s, got %q\n", src, errMsg, lit),
	}
}

type param struct {
	name  string
	_type string
}

// parseParam parses parameters of input or output.
func parseParam(s *scanner.Scanner, fset *token.FileSet, input bool) ([]param, *scanner.Error) {
	params := make([]param, 0)
	errMsg := ""

	pos, tok, lit := s.Scan()
	if input { // the input parameters could be empty
		if tok == token.RPAREN {
			return params, nil
		}
	}

	for {
		if tok != token.IDENT {
			errMsg = "expected name"
			goto _error
		}
		name := lit
		_type := ""

		pos, tok, lit = s.Scan()

		// Pointer
		if tok == token.MUL {
			_type = tok.String()
			pos, tok, lit = s.Scan()

			if tok == token.MUL {
				_type += tok.String()
				pos, tok, lit = s.Scan()
			}
		}

		// Slice
		if tok == token.LBRACK {
			_type += tok.String()

		L:
			for {
				pos, tok, lit = s.Scan()
				switch tok {
				case token.RBRACK, token.LBRACK, token.MUL:
					_type += tok.String()
				case token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:
					_type += lit
				case token.IDENT:
					break L
				default:
					errMsg = "slice got token not expected"
					goto _error
				}
			}
		}

		// Identifier
		if tok != token.IDENT {
			errMsg = "expected type"
			goto _error
		}
		_type += lit
		pos, tok, lit = s.Scan()

		if tok == token.PERIOD {
			_type += tok.String()

			pos, tok, lit = s.Scan()
			if tok != token.IDENT {
				errMsg = "expected type"
				goto _error
			}
			_type += lit
			pos, tok, lit = s.Scan()
		}

		if *IsConv {
			ok := false

			if *System == "windows" {
				_type, ok = WinToGo(_type)
			}

			if !ok {
				errMsg = "type not translated"
				lit = _type
				goto _error
			}
		}
		params = append(params, param{name, _type})

		if tok == token.RPAREN {
			break
		} else if tok == token.COMMA {
			pos, tok, lit = s.Scan()
			continue
		} else if tok == token.IDENT {
			errMsg = "expected comma"
			goto _error
		} else {
			errMsg = "expected right parenthesis"
			goto _error
		}
	}

	return params, nil

_error:
	msg := "in"
	if !input {
		msg = "out"
	}
	msg += " parameters"

	if lit == "" {
		lit = tok.String()
	}

	return params, &scanner.Error{
		fset.Position(pos),
		fmt.Sprintf("%s: %s, got %q", msg, errMsg, lit),
	}
}

// == Format
//

// formatVar formats the variables.
func formatVar(src *bytes.Buffer) error {
	pkg := "package foo\n" // must be added to be parsed
	_src := new(bytes.Buffer)
	_src.WriteString(pkg)

	src.WriteTo(_src)

	fmt, err := format.Source(_src.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	out := new(bytes.Buffer)
	out.Write(fmt)

	_out := out.String()
	_out = strings.Replace(_out, pkg+"\n", "", 1) // remove the package line

	out = new(bytes.Buffer)
	out.WriteString(_out)
	*src = *out

	return nil
}

// == Conversion
//

// WinToGo translates a Windows type definition into Go definition.
//
// To indicate that a type name is a struct, there is to preffix it with '__'
// if it is going to be private or with '_' when it is going to be public.
func WinToGo(wtype string) (string, bool) {
	pointer := ""
	if wtype[0] == '*' {
		wtype = wtype[1:]
		pointer = "*"
	}

	// http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx
	switch wtype {
	case "BOOL", "BOOLEAN":
		return pointer + "bool", true

	// int

	case "SHORT":
		return pointer + "int16", true

	case "int", "LONG":
		return pointer + "int32", true

	// uint

	case "BYTE", "CHAR", "CCHAR":
		return pointer + "byte", true
	case "LPCSTR", "LPSTR":
		return pointer + "*byte", true

	case "ATOM", "TCHAR", "WCHAR", "WORD":
		return pointer + "uint16", true
	case "LPCTSTR", "LPTSTR", "LPCWSTR", "PWSTR":
		return pointer + "*uint16", true

	case "DWORD", "UINT":
		return pointer + "uint32", true
	case "LPDWORD":
		return pointer + "*uint32", true

	case "LONG_PTR", "ULONG_PTR", "LPARAM", "LRESULT", "LPVOID", "WNDPROC", "WPARAM":
		return pointer + "uintptr", true

	// ==

	case "HANDLE", "HBRUSH", "HCURSOR", "HICON", "HINSTANCE", "HMENU", "HMODULE", "HWND":
		return pointer + "syscall.Handle", true

	case "error":
		return wtype, true
	}

	// Struct
	if wtype[0] == '_' {
		if wtype[1] == '_' { // Private
			wtype = wtype[2:]
			pointer += "_"
		} else { // Public
			wtype = wtype[1:]
		}

		if wtype[0] == 'P' {
			return "*" + pointer + wtype[1:], true
		} else if wtype[0] == 'L' && wtype[1] == 'P' {
			return "*" + pointer + wtype[2:], true
		}
		return pointer + wtype, true
	}

	return wtype, false
}
